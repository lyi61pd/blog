---
title: 数据结构
date: 2025-04-03
---

快速回忆下大学的数据结构课， 这些看完， 大概下面这些能理解一点啦~

- 树
- 二叉查找树
- 完全二叉树
- 平衡二叉树
- n叉树
- 树的遍历
- B+树
- 跳表
- 红黑树
- AVL树
- B树

# 树的基本概念
学习树的基础是理解更复杂的树结构（如红黑树、AVL树等）的前提。让我们从最基本的树概念开始。

**树**（Tree）是一种非线性的数据结构，由节点（Node）组成，节点之间通过边（Edge）连接。树的结构很像倒立的家谱图或者文件系统的结构。

树是由根节点（Root）开始，经过多个层级的分支（Branch），直到叶子节点（Leaf）

## 树的基本术语：
+ **根节点（Root）**：树的起始节点，没有父节点。
+ **节点（Node）**：树中的每个元素，包含数据部分以及指向其他节点的指针（或引用）。
+ **边（Edge）**：节点之间的连接。
+ **子节点（Child）**：直接连接到某个节点的节点，称为该节点的子节点。
+ **父节点（Parent）**：一个节点的直接连接节点是它的父节点。
+ **叶子节点（Leaf）**：没有子节点的节点。
+ **高度（Height）**：树的高度是从根节点到最深的叶子节点的最长路径的长度（也可以理解为树的层级数）。
+ **深度（Depth）**：节点的深度是从根节点到该节点的路径长度。
+ **层级（Level）**：树中的每一层，通常层级从0开始（根节点是第0层）。

## 树的类型
树可以有不同的形式，以下是几种常见的树类型：

### 二叉树 (Binary Tree)
+ **定义**：每个节点最多有两个子节点，通常称为左子节点和右子节点。
+ **特点**：
    - 每个节点最多有两个子节点。
    - 二叉树的每个节点可以有不同数量的子节点（0个、1个或2个）。
+ **用途**：二叉树是很多复杂树结构的基础，例如二叉查找树、堆等。

### 二叉查找树 (Binary Search Tree, BST)
+ **定义**：它是一种特殊的二叉树，节点的左子树上的所有值都小于节点的值，右子树上的所有值都大于节点的值。
+ **特点**：
    - 左子树的所有节点的值都小于根节点。
    - 右子树的所有节点的值都大于根节点。
    - 这使得搜索操作可以通过比较快速地确定走向左子树还是右子树。
+ **用途**：用于实现高效的查找、插入、删除等操作。

### 完全二叉树 (Complete Binary Tree)
+ **定义**：一个二叉树，除了最后一层外，其他层都是满的，并且最后一层的节点都靠左排列。
+ **特点**：
    - 除了最后一层，其他层的节点数量都是满的。
    - 最后一层的节点从左到右填充。
+ **用途**：常用于堆（如大顶堆和小顶堆）等数据结构。

### 平衡二叉树 (Balanced Binary Tree)
+ **定义**：平衡二叉树是一种二叉树，要求每个节点的左右子树高度差不超过一定的范围（如 AVL 树就是一种平衡二叉树）。
+ **特点**：
    - 保证树的高度较低，避免树退化成链表。
    - 高效的查找、插入和删除操作。
+ **用途**：如 AVL 树、红黑树等，广泛用于数据库索引。

### n叉树 (n-ary Tree)
+ **定义**：n叉树是每个节点最多有n个子节点的树。
+ **特点**：
    - 每个节点最多有n个子节点。
    - 常用于表示具有多层次的复杂数据结构，如文件系统。

## 树的遍历
树的遍历是指访问树中所有节点的过程。常见的树的遍历方式有三种：

### 前序遍历 (Preorder Traversal)
+ **步骤**：先访问当前节点，然后递归地前序遍历左子树，再递归地前序遍历右子树。
+ **顺序**：根节点 → 左子树 → 右子树。

### 中序遍历 (Inorder Traversal)
+ **步骤**：递归地中序遍历左子树，访问当前节点，然后递归地中序遍历右子树。
+ **顺序**：左子树 → 根节点 → 右子树。
+ **特点**：二叉查找树的中序遍历结果是按从小到大的顺序排列的。

### 后序遍历 (Postorder Traversal)
+ **步骤**：递归地后序遍历左子树，再递归地后序遍历右子树，然后访问当前节点。
+ **顺序**：左子树 → 右子树 → 根节点。

### 层次遍历 (Level Order Traversal)
+ **步骤**：按层级遍历树的节点，通常使用队列来实现。
+ **顺序**：根节点 → 第一层 → 第二层 → 第三层 → ……直到最后一层。

## 树的应用
树作为一种数据结构，有许多实际应用，常见的包括：

+ **文件系统**：文件和目录组织成树形结构，根目录是树的根节点，文件和文件夹是节点。
+ **数据库索引**：树结构（如B树、B+树）常用于数据库的索引，帮助快速查找数据。
+ **游戏决策树**：用于表示游戏中的可能决策路径。



---

## 二叉查找树（Binary Search Tree, BST）
### 定义
二叉查找树是一种特殊的二叉树，满足以下性质：

+ 每个节点最多有两个子节点。
+ 左子树中所有节点的值小于根节点。
+ 右子树中所有节点的值大于根节点。
+ 每一棵子树也都是一棵二叉查找树。

### 操作
**查找（Search）**

从根节点开始：

+ 如果目标值等于当前节点，返回。
+ 如果目标值小于当前节点，进入左子树。
+ 如果目标值大于当前节点，进入右子树。

查找的时间复杂度与树的高度有关，最坏是 O(n)，最优是 O(log n)。

**插入（Insert）**

插入值时，按查找路径向下走，找到空位插入即可，不会破坏 BST 结构。

**删除（Delete）**

分三种情况处理：

1. 删除叶子节点，直接删除。
2. 删除只有一个子节点的节点，用子节点替换该节点。
3. 删除有两个子节点的节点，找到该节点的中序后继或中序前驱，用它的值替换当前节点，再删除那个节点。

### 问题：BST 可能退化成链表
如果连续插入有序数据，例如 1、2、3、4、5，树就会变成单边链表，导致查找效率退化为 O(n)。

为了解决这个问题，就需要引入“自平衡”的机制，也就是平衡二叉树。

---

## 平衡二叉树的基本思想
### 什么是平衡
树的高度决定了查找、插入、删除的效率。所谓平衡，是指尽量保持每个节点的左右子树高度差不要太大，避免形成单边长链。

平衡树的目标是让树的高度保持在 O(log n) 以内，从而提高整体性能。

### 平衡的实现手段：旋转操作
当插入或删除节点后导致失衡，可以通过旋转操作让树重新平衡。

**左旋**

将某个节点的右子节点提升为新的父节点，原父节点变为其左子节点。

例子： 节点 A 有右子节点 B，B 再有右子节点 C

```plain
原始结构：
    A
     \
      B
       \
        C

左旋后：
    B
   / \
  A   C
```

**右旋**

将某个节点的左子节点提升为新的父节点，原父节点变为其右子节点。

例子： 节点 C 有左子节点 B，B 再有左子节点 A

```plain
原始结构：
    C
   /
  B
 /
A

右旋后：
    B
   / \
  A   C
```

通过这些旋转，可以动态调整树结构，使其保持平衡。

---

## 红黑树简介
红黑树是自平衡的二叉查找树，它使用颜色和旋转来控制树的高度。

红黑树不是严格平衡的，但它能保证最长路径不会超过最短路径的两倍，因此效率稳定。

### 红黑树的五个性质
1. 每个节点是红色或黑色。
2. 根节点必须是黑色。
3. 所有叶子节点（NIL 节点）是黑色。
4. 如果一个节点是红色的，则它的两个子节点必须是黑色的（不能连续两个红色节点）。
5. 从任意节点到其所有叶子节点的路径上，包含的黑色节点数量必须相同。

这些性质共同保证了树的平衡性。

---

## 总结
+ 普通二叉查找树查找效率依赖于树高，可能退化成链表。
+ 平衡二叉树通过旋转操作保持结构平衡，提升查找、插入、删除性能。
+ 红黑树是一种宽松的平衡树，通过颜色约束加旋转来维持近似平衡。
+ 红黑树是很多底层库和系统（如 Java TreeMap、C++ STL、Linux 内核）使用的高效结构。

---

# 红黑树与 AVL 性能对比，如何选型
这是一个很实用、也很容易被误解的问题。我们来进行一次**实事求是**的对比，站在工程实践的角度，讲清楚 **红黑树 vs AVL 树 的性能差异、适用场景、优缺点、如何选型**。

---

## 红黑树与 AVL 树的核心差异
| 比较点 | AVL 树 | 红黑树 |
| --- | --- | --- |
| 平衡性 | 严格平衡（左右子树高度差 ≤ 1） | 相对平衡（通过颜色规则控制） |
| 插入效率 | 较慢，可能频繁旋转 | 较快，旋转次数更少 |
| 删除效率 | 更慢（容易失衡） | 更快（更容忍不平衡） |
| 查找效率 | 稍快（更矮更“紧凑”） | 稍慢（更高一些） |
| 实现复杂度 | 中等 | 略高，染色逻辑更麻烦 |
| 实际树高 | log(n)，更低 | 最坏 2log(n)，略高但可接受 |
| 应用场景 | 查找密集 | 插入/删除频繁 |


---

## 时间复杂度对比（理论上相同）
| 操作 | AVL | 红黑树 |
| --- | --- | --- |
| 查找 | O(log n) | O(log n) |
| 插入 | O(log n) + 最多 2 次旋转 | O(log n) + 最多 3 次旋转 + 染色 |
| 删除 | O(log n) + 最多 log n 次旋转 | O(log n) + 最多 3 次旋转 + 染色 |


**注意**：红黑树旋转次数少于 AVL，是因为它更“宽松”地控制平衡。

---

## 为什么工程中更常用红黑树？
### 1. 插入、删除性能更稳定
AVL 树插入删除操作中需要频繁调整结构（旋转），因为它追求高度的平衡性。虽然这保证了查找很快，但维护成本高。

红黑树采用更“保守”的平衡策略，调整动作较少，**整体吞吐量更好**。这在系统级开发中非常重要，比如操作系统、数据库、语言运行时。

### 2. 插入/删除频率高时，红黑树吞吐量优于 AVL
AVL树适合“读多写少”的场景，比如缓存系统。

红黑树适合“读写都频繁”的场景，比如内核调度、任务队列、映射表等。

---

## 实际案例对比
### Java `TreeMap` / `TreeSet`
+ 使用的是 **红黑树** 实现
+ 原因：Java中集合类通常面对频繁插入和删除（如实时排序、排名等），红黑树性能更均衡

### C++ STL 的 `std::map` / `std::set`
+ 也使用的是 **红黑树**
+ 同样考虑的是泛型容器的插入/删除复杂度

### Linux 内核调度器 / 时间红黑树（RB-tree）
+ 使用的是红黑树（见 `include/linux/rbtree.h`）
+ 因为调度器中的进程插入/删除频繁，而查找不一定多，所以使用红黑树性能更佳

---

## 什么时候选 AVL 树？
虽然工程里红黑树更常见，但 **AVL 并不是没用**，它在以下场景下依然有价值：

+ 对查找性能要求极致，数据变动频率低的场景
    - 如**内存索引、缓存服务、读密集型数据库**
+ 数据量适中，性能压力可控，希望保证查找时间始终最优

比如：一个静态配置中心，你预先插入一些配置项，然后主要是查找访问。用 AVL 是合理的。

---

## 工程选型建议总结
| 场景 | 推荐结构 | 原因 |
| --- | --- | --- |
| 查找频繁、插入删除极少 | AVL | 查找快，保持严格平衡 |
| 插入/删除频繁，查找适中 | 红黑树 | 性能更均衡，旋转少 |
| 需要范围查询 | B+树 | 存储系统常用结构（如数据库） |
| 高并发环境下 | 并发跳表 / 哈希表 | 红黑树/AVL 不擅长并发控制 |
| 内核、调度系统 | 红黑树 | 插入/删除频繁，吞吐量更重要 |
| 学术 / 教学用 | AVL | 更容易推导、理解平衡原理 |


---

## 总结一句话
**红黑树是工业界的主流选型，因为它在保持平衡和性能之间做了非常合理的权衡。**

而 AVL 更适合做“查找效率最优”的算法研究、教学或低变更场景。



# B树、B+树、跳表
非常好，接下来我们进入数据库/存储系统中常用的三种结构：**B树、B+树、跳表**，它们都是用于**范围查找、批量排序、动态插入删除**等复杂需求下的数据结构。

我会按这个顺序讲解：

1. **先讲 B 树**：基础结构，理解它是后续 B+ 树的前提
2. **再讲 B+ 树**：数据库索引、文件系统最常用结构
3. **最后讲跳表**：高性能内存结构，Redis 的最爱

每一个我们都会涵盖：

+ 是什么（直观理解）
+ 如何组织数据
+ 查找/插入/删除怎么做
+ 为什么它适合某类场景

---

## B 树（Balanced Tree / 多路平衡查找树）
### 是什么
B 树是一种**多路搜索树**，是对二叉搜索树的推广。每个节点不仅可以有两个子节点，而是可以有多个。  
广泛用于**磁盘存储、数据库索引结构**中，因为它减少了磁盘读写次数。

### 特点
+ 每个节点最多有 `m-1` 个数据项，`m` 个子指针（m 是阶数）
+ 所有节点的关键字保持有序
+ 插入、删除后依然保持平衡
+ 所有叶子节点在同一层（树高固定）

### 举例（以3阶 B 树为例）
+ 一个节点最多 2 个键，最多有 3 个子节点
+ 比如节点中有 [10, 20]，它的子树范围：
    - 子树1：小于 10
    - 子树2：10~20
    - 子树3：大于 20

### 查找
和二分查找类似：

+ 从根节点开始，在节点中查找关键字位置（可以使用二分）
+ 找不到则沿对应子树向下

时间复杂度为 O(log n)，**但每一层“跨度大”，所以树的高度更低，查找更快**

### 插入
+ 找到插入位置，插入键
+ 如果节点已满，就**分裂节点**，中间值“上提”到父节点
+ 插入可能从叶子一路调整到根节点，最多增加一层高度

### 删除
+ 类似 BST，找到值删掉
+ 如果节点删除后不满足最小关键字数量，就需要**向兄弟借值或合并节点**
+ 复杂度 O(log n)

### 应用场景
+ MySQL 的 MyISAM 引擎使用的是 **B 树索引**
+ 适合中等范围查询、单点查找、插入删除都频繁的磁盘结构

---

## B+ 树（B Tree 的增强版）
### 是什么
B+ 树是 B 树的一个变种，**所有值都存在叶子节点**，非叶子节点只做“导航”。

**MySQL InnoDB、文件系统、LevelDB 等都使用 B+ 树作为索引结构。**

### 和 B 树的区别
| 特性 | B 树 | B+ 树 |
| --- | --- | --- |
| 数据存储 | 所有节点存数据 | 只有叶子节点存数据 |
| 内部节点 | 数据 + 导航 | 仅导航（索引） |
| 查找路径 | 可提前终止 | 一定走到叶子节点 |
| 范围查询 | 差 | 强（叶子节点有链表） |


### 特点
+ 所有叶子节点通过链表串起来，方便范围查询
+ 非叶子节点只做索引，节省空间，**扇出更高，树更矮**
+ 结构更适合磁盘块对齐，减少 IO 次数

### 查找
+ 和 B 树类似，但一定查到叶子节点才能拿到数据
+ 路径更统一，便于实现

### 范围查询
+ 特别高效，只需要找到范围起点，然后从链表顺着读下去即可

### 应用场景
+ **数据库索引（MySQL InnoDB）**
+ **文件系统（如 NTFS, XFS）**
+ 批量范围读取、数据分页、高并发写场景

---

## 跳表（Skip List）
### 是什么
跳表是一种通过在链表上建立多级索引的方式实现快速查找的数据结构。

你可以理解为：**链表 + 多层快速通道**，是“概率化”实现的平衡树。

### 结构
+ 底层是有序链表（维护所有元素）
+ 每一层随机选取一些节点参与“快速通道”
+ 每一层都是下一层的子集，最顶层最稀疏

比如有 16 个节点，可能层结构像这样：

```plain
Level 3:      A --------- H
Level 2:      A ---- E -- H -- M
Level 1: A - B - C - D - E - F - G - H - I - ... - P
```

### 查找
+ 从顶层开始，逐层往下，直到定位到目标位置
+ 每次跳跃跨度大，大大加快查找速度

平均时间复杂度：O(log n)

### 插入 / 删除
+ 插入新节点后，按概率决定它会出现在多少层（比如 Redis 是1/4 概率上升一层）
+ 删除也是先找到节点，再清理所有层级中的引用

时间复杂度：O(log n)

### 应用场景
+ **Redis 的 zset（有序集合）使用跳表实现**
+ 比树更容易实现，适合内存结构、并发场景
+ 查找、插入、删除都非常高效
+ 不需要复杂的旋转、维护，代码比平衡树更简单

---

## 三者对比总结
| 特性 | B 树 | B+ 树 | 跳表 |
| --- | --- | --- | --- |
| 查找效率 | O(log n) | O(log n) | O(log n) |
| 插入/删除 | O(log n) | O(log n) | O(log n)（更简单） |
| 是否适合磁盘 | 是 | 是（最佳） | 否，适合内存 |
| 是否适合范围查询 | 一般 | 强（链表） | 强（链表） |
| 实现复杂度 | 中 | 中高 | 低（逻辑简单） |
| 工程应用 | MyISAM索引 | InnoDB索引，文件系统 | Redis zset、有序内存结构 |


---

## 总结建议
+ **数据库磁盘索引**：使用 B+ 树。查找、范围查询快，IO次数少，MySQL/Oracle/SQLite都用它。
+ **键值对内存结构（Redis）**：用跳表。简单好用，查找/插入性能稳定。
+ **老的存储结构或小范围索引**：B 树也能用，但现在基本被 B+ 树取代。

---

## B树和B+树对比
+ **B树** 和 **B+树** 都是自平衡的多路查找树，它们通过分支节点和数据节点组织数据，确保了对大规模数据的高效查找。
+ **B+树** 相比于 **B树**，更加高效，特别是在 **范围查询** 和 **顺序访问** 上，因此在数据库和文件系统中，B+树的应用更加广泛。
+ **B树** 适合需要 **较少的范围查询** 或 **较均衡的查找操作** 的场景，而 **B+树** 更适合 **大规模数据存储、范围查询和顺序扫描** 的场景。

---

# 什么是 AVL 树？
**AVL 树** 是一种 **自平衡的二叉查找树（Binary Search Tree, BST）**，它的全称是：

**Adelson-Velsky and Landis Tree**  
由两位苏联科学家在 1962 年提出，是世界上第一个自平衡二叉查找树。

---

## AVL 树的核心特性
### 自平衡的定义
对于 **树中的每一个节点**，都必须满足：

**左子树和右子树的高度差 ≤ 1**

这个高度差我们称为该节点的 **平衡因子（Balance Factor）**，它的取值只能是：

+ -1（右子树比左子树高一层）
+ 0（左右等高）
+ +1（左子树比右子树高一层）

一旦插入或删除节点后某个节点的平衡因子超过这个范围（比如变成了 2 或 -2），就需要**通过旋转操作来恢复平衡**。

---

## 为什么需要 AVL 树？
普通的二叉查找树（BST）在最坏情况下会退化成链表，导致操作效率变为 O(n)。  
而 AVL 树通过强制控制“平衡因子”，保持**树高度为 O(log n)**，确保：

+ 查找（Search）
+ 插入（Insert）
+ 删除（Delete）

这些操作都能在对数时间内完成。

---

## AVL 树的旋转操作
### 单旋（Single Rotation）
1. **右旋（Right Rotation）**  
用于左子树过高（LL 失衡）
2. **左旋（Left Rotation）**  
用于右子树过高（RR 失衡）

### 双旋（Double Rotation）
1. **先左旋再右旋（Left-Right Rotation）**  
用于插入到左子树的右子树（LR 型失衡）
2. **先右旋再左旋（Right-Left Rotation）**  
用于插入到右子树的左子树（RL 型失衡）

---

## 操作复杂度
| 操作 | 时间复杂度 |
| --- | --- |
| 查找 | O(log n) |
| 插入 | O(log n)（可能旋转） |
| 删除 | O(log n)（可能多次旋转） |


AVL 树高度非常低，接近 log₂(n)，因此查找性能极优。

---

## 示例
假设我们依次插入以下节点：10 → 20 → 30

普通 BST 结构变成：

```plain
10
  \
   20
     \
      30
```

此时树高度为 3，已经失衡，AVL 会做一次左旋，变成：

```plain
20
   /  \
  10  30
```

保持了平衡。

---

## AVL 树 vs 红黑树
| 对比项 | AVL 树 | 红黑树 |
| --- | --- | --- |
| 平衡程度 | 更严格（左右子树高差 ≤ 1） | 较宽松（限制黑节点数目） |
| 插入/删除效率 | 较慢，旋转多 | 较快，旋转少 |
| 查找效率 | 稍快 | 稍慢 |
| 实际应用 | 内存查找、读多写少 | 系统结构、写操作多 |
| 实现复杂度 | 中 | 高 |


---

## 适用场景
+ 查找频率高，插入/删除少的场景，如内存中的索引结构
+ 不适合频繁更新的场景，因为每次插入/删除都可能触发旋转

---

# B树与平衡二叉查找树的对比
| 特性 | **B树** | **平衡二叉查找树（如 AVL 树、红黑树）** |
| --- | --- | --- |
| **适用场景** | 大规模数据存储，尤其是磁盘存储；数据库索引，文件系统管理 | 内存中的动态数据存储，集合、映射、优先队列等 |
| **树的结构** | 多路树，每个节点有多个子节点 | 二叉树，每个节点最多有两个子节点 |
| **查找性能** | O(log n)，但通常更适合磁盘存储，减少磁盘访问次数 | O(log n)，在内存中查找非常高效 |
| **节点大小** | 每个节点包含多个键和多个子指针，适合减少磁盘访问次数 | 每个节点只包含一个键和最多两个子指针 |
| **插入/删除操作** | 节点分裂/合并，通常需要更复杂的操作来保持平衡 | 旋转操作，通过保持平衡因子来保证平衡 |
| **支持范围查询** | 非常高效，能够快速查找和遍历范围数据 | 支持范围查询，但对于大量范围查询不如 B 树高效 |
| **内存与存储** | 适合外存存储，能高效处理大量数据 | 适用于内存数据管理，数据规模适中，内存存储 |


