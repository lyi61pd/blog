---
title: CVE-2021-3156
date: 2025-04-17
tags:
    - 漏洞分析
    - 漏洞复现
---

### 漏洞原理

在sudo的`parse_args()`函数中，重写了`argv`，将命令行的参数存储到`cmnd`中(587-595行)，将参数中的字母数字_-$以外的字符，也就是元字符，前面加上反斜杠\来转义处理（590-591行）



```c
571     if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) { 
572         char **av, *cmnd = NULL; 
573         int ac = 1; 
... 
581             cmnd = dst = reallocarray(NULL, cmnd_size, 2); 
... 			// 将命令行的参数存储到dst,即cmnd中
587             for (av = argv; *av != NULL; av++) { 
588                 for (src = *av; *src != '\0'; src++) { 
589                     // 除了字母数字_-$以外的字符，前面加上反斜杠\来转义
590                     if (!isalnum((unsigned char)*src) && *src != '_' && *src != '-' && *src != '$') 
591                         *dst++ = '\\'; 
592                     *dst++ = *src; 
593                 } 
594                 *dst++ = ' '; 
595             } 
... 
600             ac += 2; /* -c cmnd */ 
... 
603         av = reallocarray(NULL, ac + 1, sizeof(char *)); 
... 		// 根据cmnd重写argv和argc
609         av[0] = (char *)user_details.shell;
610         if (cmnd != NULL) { 
611             av[1] = "-c"; 
612             av[2] = cmnd; 
613         } 
614         av[ac] = NULL; 
615  
616         argv = av; 
617         argc = ac; 
618     }
```



之后，在`sudoers_policy_main()`，`set_cmnd()`函数中，会把前面重写的`argv`进行解析，解析的内容存储到`user_args`变量中，在解析时对使用反斜杠\的字符进行反转义处理时（590-591行），逻辑出现问题



```c
819     if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) { 
... 
852             for (size = 0, av = NewArgv + 1; *av; av++) 
853                 size += strlen(*av) + 1; 
854             if (size == 0 || (user_args = malloc(size)) == NULL) { 
... 
857             } 
858             if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) { 
... 
864                 for (to = user_args, av = NewArgv + 1; (from = *av); av++) { 
865                     while (*from) { 
    						// 当遇到反斜杠字符，且下一个字符不是空白字符时，会跳过
866                         if (from[0] == '\\' && !isspace((unsigned char)from[1])) 
867                             from++; 
868                         *to++ = *from++; 
869                     } 
870                     *to++ = ' '; 
871                 } 
... 
884             } 
... 
886     }
```



如果命令行参数是以一个单独的反斜杠\结尾的，比如`test\`，就会出现问题：



+  首先会将`test\`中的 `t` `e` `s` `t` 逐个传递给`to`变量，也就是`user_args`变量，然后当循环到`\`时，情况如下 
+  首先在866行，from[0]是一个反斜杠，并且from[1]是null终止符，这里要注意null终止符并不是空白字符，也就是`isspace`函数返回值为否，判断通过 
+  在867行，会对from进行加一，此时from指向的就是刚才的from[1]，也就是一个null终止符 
+  在868行，会将当前的from的内容，即null终止符传递给`to`变量，即`user_args`变量，并且`from`再次加一，这时`from`已经超出了命令行参数的边界了 
+  之后整个while循环会继续运行，把超出命令行参数边界的字符也传递给`user_args`变量 



因为`user_args`在852-853行，已经指定了`user_args`变量申请的堆的大小，而上面的循环中却把越界的内容传递给了`user_args`，因此`set_cmnd()`函数存在堆溢出漏洞



但是，如何把一个单独的反斜杠结尾的字符作为命令行参数，传递到`set_cmnd()`函数中呢？



回到前面的`parse_args()`函数中，在590-591行，对元字符（字母数字_-$以外的字符）前面加了反斜杠处理，也就是说，如果某个参数是`test\`，那么经过`parse_args()`函数后，就会变成`test\\`，然后进入到`set_cmnd()`函数，此时不会出现堆溢出的情况**(为什么**`**test\\**`**不会溢出，过程是怎样的)**，那么如何才能只传递`test\`到`set_cmnd()`函数这里呢？



回到571行，关于`MODE_RUN`和`MODE_SHELL`的条件判断，满足这个条件才会对参数中的元字符前面加上反斜杠处理



```plain
571     if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {
```



在819行和858行，满足这两处判断才能到达存在堆溢出漏洞的代码



```plain
819     if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) { 
... 
858             if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
```



那么可以有这样一个想法：满足819行和858行的判断条件，并且不满足571行的判断条件，这样就能把`test\`不经过元字符处理传递到堆溢出漏洞的代码处



+  首先，要满足858行，可以通过`-s`参数设置`MODE_SHELL`，或者通过`-i`参数可以同时设置`MODE_LOGIN_SHELL`和`MODE_SHELL`，这两种均可 
+  那么接下来，就需要不满足`MODE_RUN`，并且满足`MODE_EDIT`或`MODE_CHECK`**（这个条件是怎么得出来的）** 



sudo的mode参数和flags参数是通过sudo命令执行时的参数来确定的，对sudo的参数进行研究，主要为`-e`参数和`-l`参数，代码如下：



```plain
358                 case 'e': 
... 
361                     mode = MODE_EDIT; 
362                     sudo_settings[ARG_SUDOEDIT].value = "true"; 
363                     valid_flags = MODE_NONINTERACTIVE; 
364                     break; 
... 
416                 case 'l': 
... 
423                     mode = MODE_LIST; 
424                     valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST; 
425                     break; 
... 
518     if (argc > 0 && mode == MODE_LIST) 
519         mode = MODE_CHECK; 
... 
532     if ((flags & valid_flags) != flags) 
533         usage(1);
```



如果使用-e参数，会设置`MODE_EDIT`，并且在363行设置了有效的`flags`，其中没有包括`MODE_SHELL`这将会导致无法满足858行的判断条件，因此不符合



如果使用-l参数，会设置`MODE_CHECK`，并在424行设置有效的`flags`，其中也没有包括`MODE_SHELL`，也会导致无法满足858行的判断条件，因此使用`-l`参数也不行



看起来要满足819行和858行，并且不满足571的判断条件是做不到了，怎么办？



这时就涉及到`sudoedit`命令了，sudoedit其实本体就是sudo二进制文件，不过是将sudo二进制文件改了个名字叫做sudoedit而已



所以下面还是查看sudo的源码，有这样一个漏洞：



```c
127 #define DEFAULT_VALID_FLAGS     (MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL) 
... 
249     int valid_flags = DEFAULT_VALID_FLAGS; 
... 
267     proglen = strlen(progname); 
268     if (proglen > 4 && strcmp(progname + proglen - 4, "edit") == 0) { 
269         progname = "sudoedit"; 
270         mode = MODE_EDIT; 
271         sudo_settings[ARG_SUDOEDIT].value = "true"; 
272     }
```



在268行，如果程序名的后四位为`edit`，就设置`mode`为`MODE_EDIT`



通过下面的命令，就能同时设置`MODE_EDIT`和`MODE_SHELL`，成功到达存在堆溢出漏洞的代码了：



```plain
sudoedit -s
```



然后想要实现堆溢出，就需要反斜杠参与，可以尝试下面的命令进行溢出



```plain
sudoedit -s '\' `perl -e 'print "A" x 65536'`
```



从攻击者的角度思考，这个堆溢出漏洞是很理想的：



1. `user_args`申请的堆的大小是可控的
2. 堆溢出的内容也是可控的
3. 攻击者可以向溢出的内容加入null终止符



### 漏洞复现


通过提前搭建好的docker镜像来复现，里面有sudo源码，exp，pwndbg，复现的同时也便于进行分析



```plain
docker pull chenaotian/cve-2021-3156
```



### 漏洞修复


存在漏洞的代码主要是这个逻辑判断存在问题



```c
if (from[0] == '\\' && !isspace((unsigned char)from[1]))
```



可以采用简单直接的方式进行修改：增加一个逻辑判断



```c
if (from[0] == '\\' && !isspace((unsigned char)from[1]) && from[1]!='\0')
```



制作修复补丁：



```plain
diff -uNr a b > CVE-2021-3156.patch		
制作补丁，该补丁是给a打的，如果打了该补丁a就会和b一样，-u可以调整输出的格式更规范一些, -N确保正确处理新增和删除的文件, -r递归处理子目录，应该是文件夹都需要用-r来处理

patch -p0 < CVE-2021-3156.patch	
打补丁，-p0说明当前目录的级数为0级

patch -p0 -RE < CVE-2021-3156.patch	
取消刚才打的补丁
```



### 修复验证


通过下面命令重新编译安装sudo



```plain
./configure
make
make install
```



然后重新运行exp，无法成功获取到shell，说明修复成功



### deb打包


```plain
mkdir sudo-custom/DEBIAN -p
mkdir sudo-custom/usr/local/bin -p
vim sudo-custom/DEBIAN/control
```



内容如下



```plain
Package: sudo-custom
Version: 1.0-1
Architecture: amd64
Maintainer: user*** <pu*****@he***.world>
Description: hello,world
Depends: libc6(>= 2.26)
```



继续执行



```plain
cp /root/sudo-1.8.21/src/sudo /root/sudo-custom/usr/local/bin/sudo
cp /root/sudo-1.8.21/src/.libs /root/sudo-custom/usr/local/bin/.libs -r
dpkg-deb -b sudo-custom /root/sudo-custom.deb
dpkg -i sudo-custom.deb
sudo whoami
```



